# $Id$
# Copyright (c) 2009 Oliver Beckstein <orbeckst@gmail.com>
# Released under the GNU Public License 3 (or higher, your choice)
# See the file COPYING for details.

"""
:mod:`analysis.core` -- Core classes for analysis of Gromacs trajectories
=========================================================================

This documentation is mostly of interest to programmers who want to write
analysis plugins.


Programming API for plugins
---------------------------

Additional analysis capabilities are added to a
:class:`gromacs.analysis.Simulation` class with mixin classes; these mixin
classes are the *plugins*.

Example usage
.............

Derive class for the simulation of interest along the lines of ::

     from gromacs.analysis import Simulation
     from gromacs.analysis.plugins import CysAccessibility, Distances

     class MyProtein(Simulation, CysAccessibility, Distances):
       def __init__(self,**kwargs):
           kwargs['CysAccessibility'] = {'cysteines': [96, 243, 372]}
           super(MyProtein,self).__init__(**kwargs)

     S = MyProtein(tpr=..., xtc=..., analysisdir=...)
     S.set_default_plugin('CysAccessibility')  # do CysAccessibility for now
     S.run()                                   # generate data from trajectories
     S.analyze()                               # analyze data
     S.plot(figure=True)                       # plot and save figures


API description
...............

Analysis capabilities can be added by mixing in additional plugins into the
simulation base class. Each plugin registers itself and provides at a minimum
:meth:`run()`, :meth:`analyze()`, and :meth:`plot()` methods.

The plugin class is derived from :class:`Plugin` and bears the name that is used to
access it. When its :meth:`__init__` method executes it adds the actual worker class
(typically named with the underscore-prepended name) to the :attr:`Simulation.plugins`
dictionary.

Variables for initializing a plugin are given to the class constructor as a
keyword argument that is named like the plugin and contains a dictionary that
is used as the keyword parameters for the plugin's init.

A plugin **must** obtain a pointer to the :class:`Simulation` class as the keyword
argument ``simulation`` in order to be able to access simulation-global
parameters such as top directories or input files.

See :class:`analysis.plugins.CysAccessibility` and
:class:`analysis.plugins._CysAccessibility` in
``analysis/plugins/CysAccessibility.py`` as examples.


API requirements
................

* Each plugin is contained in a separate module in the
  :mod:`gromacs.analysis.plugins` package. The name of the module *must* be the
  name of the plugin class in all lower case.

* The plugin name is registered in
  :const:`gromacs.analysis.plugins.__plugins__`. (Together with the file naming
  convention this allows for automatic and consistent loading.)

* The plugin itself is derived from :class:`Plugin`; the only changes are the
  doc strings and setting the :attr:`Plugin.plugin_name` class attribute.

* The corresponding worker class is derived from :class:`Worker` and must implement 
  
  - :meth:`Worker.__init__` which can only use keyword arguments to initialize
    the plugin. It must ensure that init methods of super classes are also
    called. See the existing plugins for details.

  - :meth:`Worker.run` which typically generates the data by analyzing a
    trajectory, possibly multiple times. It should store results in files.

  - :meth:`Worker.analyze` analyzes the data generated by :meth:`Worker.run`.

  - :meth:`Worker.plot` plots the analyzed data.

* The worker class can access parameters of the simulation via the
  :attr:`Worker.simulation` attribute that is automatically set when the plugin
  registers itself with :class:`Simulations`.

* Parameters of the plugin are stored in :attr:`Worker.parameters` (either as
  attributes or as key/value pairs, see the container class
  :class:`AttributeDict`).

* Results are stored in :attr:`Worker.results` (also a :class:`AttributeDict`).


Classes
-------

.. autoclass:: Simulation
   :members: __init__, set_default_plugin, run, analyze, plot, 
            topdir, plugindir, check_file, has_plugin, check_plugin_name, select_plugin

.. autoclass:: Plugin
   :members: __init__   

.. autoclass:: Worker   
   :members: __init__, topdir, plugindir, savefig
   :show-inheritance:

.. autoclass:: AttributeDict


"""
__docformat__ = "restructuredtext en"

import sys
import os
import errno
import subprocess
import warnings

from gromacs.utilities import FileUtils

class AttributeDict(dict):
    """A dictionary with pythonic access to keys as attributes --- useful for interactive work."""
    def __getattribute__(self,x):
        try:
            return super(AttributeDict,self).__getattribute__(x)
        except AttributeError:
            return self[x]
    def __setattr__(self,name,value):
        try:
            super(AttributeDict,self).__setitem__(name, value)
        except KeyError:
            super(AttributeDict,self).__setattr__(name, value)
            


class Simulation(object):
    """Class that represents one simulation.

    Analysis capailities are added with mixin classes. 

    Only keyword arguments are allowed so that init resolution works as
    expected.
    """
    def __init__(self, **kwargs):
        """Set up a Simulation object; analysis is performed via methods.

        :Parameters:
           tpr
             Gromacs tpr file (**required**)
           xtc
             Gromacs trajectory (**required**)
           ndx
             Gromacs index file
           analysisdir
             directory under which derived data are stored;
             defaults to the directory containing the tpr [None]        
        """
        # required files
        self.tpr = kwargs.pop('tpr',None)
        self.xtc = kwargs.pop('xtc',None)
        for v in ('tpr', 'xtc'):            
            self.check_file(v, self.__getattribute__(v))

        self.ndx = kwargs.pop('ndx',None)
        self.analysis_dir = kwargs.pop('analysisdir', os.path.dirname(self.tpr))

        # registry for plugins: This dict is central.
        self.plugins = AttributeDict()   # nicer for interactive use than dict
        self.default_plugin_name = None

        # important: Do not forget to call mixin classes:
        #            each plugin class registers itself in self.plugins[].
        super(Simulation,self).__init__(**kwargs)

        # XXX: does this work (i.e. do we end up here AFTER mixin inits??)
        # convenience: if only a single plugin was registered we default to that one
        if len(self.plugins) == 1:
            self.set_default_plugin(self.plugins.keys()[0])

    def topdir(self,*args):
        """Returns path under self.analysis_dir. Parent dirs are created if necessary."""
        p = os.path.join(self.analysis_dir, *args)
        parent = os.path.dirname(p)
        try:
            os.makedirs(parent)
        except OSError,err:
            if err.errno != errno.EEXIST:
                raise
        return p

    def plugindir(self,plugin_name,*args):
        return self.select_plugin(plugin_name).plugindir(*args)

    def check_file(self,filetype, path):
        if path is None or not os.path.isfile(path):
            raise ValueError("Missing required file %(filetype)r, got %(path)r." % vars())
        return True

    def set_default_plugin(self,plugin_name):
        """Set the plugin that should be used by default.

        If no plugin_name is supplied to run(), analyze() etc. then
        this will be used.
        """
        if plugin_name == None:
            self.default_plugin_name = None
        else:
            self.check_plugin_name(plugin_name)
            self.default_plugin_name = plugin_name
        return self.default_plugin_name

    def has_plugin(self,plugin_name):
        """Returns True if plugin_name is registered."""
        return plugin_name in self.plugins

    def check_plugin_name(self,plugin_name):
        """Raises a ValueError if plugin_name is not registered."""
        if not (plugin_name is None or self.has_plugin(plugin_name)):
            raise ValueError('plugin_name must be None or one of\n%r\n' % self.plugins.keys())

    def select_plugin(self,plugin_name=None):
        """Return valid plugin or the default for plugin_name=None."""
        self.check_plugin_name(plugin_name)
        if plugin_name is None:
            if self.default_plugin_name is None:
                raise ValueError('No default plugin was set.')
            plugin_name = self.default_plugin_name
        return self.plugins[plugin_name]

    def run(self,plugin_name=None,**kwargs):
        """Generate data files as prerequisite to analysis."""
        return self.select_plugin(plugin_name).run(**kwargs)

    def analyze(self,plugin_name=None,**kwargs):
        """Run analysis for the plugin."""
        return self.select_plugin(plugin_name).analyze(**kwargs)    

    def plot(self,plugin_name=None,figure=False,**plotargs):
        """Plot all data for the selected plugin::

          plot(plugin_name, **kwargs)

        :Arguments:
           plugin_name   
              name of the plugin to plot data from
           figure
              - True: plot to file with default name.
              - string: use this filename (+extension for format)
              - False: only display
           plotargs
              arguments for pylab.plot
        """
        return self.select_plugin(plugin_name).plot(figure=figure,**plotargs)    

    def __str__(self):
        return 'Simulation(tpr=%(tpr)r,xtc=%(xtc)r,analysisdir=%(analysis_dir)r)' % vars(self)
    def __repr__(self):
        return str(self)



# Plugin infrastructure
# ---------------------

# worker classes (used by the plugins)

class Worker(FileUtils):
    """Base class for a plugin worker."""

    #: name of the plugin that this Worker belongs to; set when deriving the 
    #: plugin's worker class
    plugin_name = None

    def __init__(self,**kwargs):
        """Set up Worker class.
        
        :Keywords:
          simulation
             A ``Simulation`` object; this is filled in by the ``Plugin`` class when the plugin 
             is registered (**required**).
          \*\*kwargs
             All other keyword arguments are passed to the super class.
        """
        assert self.plugin_name != None                  # derive from Worker
        self.simulation = kwargs.pop('simulation',None)  # required (but kw for super & friends)
        assert self.simulation != None
        self.location = None          # directory name under analysisdir (set in derived class)
        self.results = AttributeDict()
        self.parameters = AttributeDict()
        super(Worker,self).__init__(**kwargs)

    def topdir(self, *args):
        """Returns a directory located under the simulation top directory."""
        return self.simulation.topdir(*args)
    
    def plugindir(self, *args):
        """Returns a directory located under the plugin top directory."""
        return self.topdir(self.location, *args)

    def run(self,**kwargs):
        raise NotImplementedError

    def analyze(self,**kwargs):
        raise NotImplementedError

    def plot(self,**kwargs):
        raise NotImplementedError

    def savefig(self, filename=None, ext='png'):
        """Save the current figure under the default name, using the supplied format and extension."""
        import pylab
        if filename is None:
            filename = self.parameters.figname
        _filename = self.filename(filename, ext=ext, use_my_ext=True)
        pylab.savefig(_filename)
        print "Saved figure as %(_filename)r." % vars()
            

# plugins:
# registers a worker class in Simulation.plugins and adds a pointer to Simulation to worker

class Plugin(object):
    """Plugin class to be used as a mixin class with Simulation.

    All analysis plugins must be derived from the Plugin base class.

    A plugin registers a worker class in Simulation.plugins and adds a
    pointer to Simulation to worker.
    """    
    # XXX: gets overwritten with multiple plugin mixins --- do something else!
    #: name of the plugin
    plugin_name = None
    #: actual plugin class (typically name with leading underscore)
    plugin_class = None

    def __init__(self,**kwargs):
        """Registers the plugin with the simulation class.

        Specific keyword arguments are listed below, all other kwargs
        are passed through.

        :Keywords:
           plugin_name : dict     
                A dictionary named like the plugin is taken to include
                keyword arguments that are passed to the __init__ of the plugin.
        """
        assert self.plugin_name != None                # must derive from Plugin
        plugin_args = kwargs.pop(self.plugin_name,{})  # must be a dict named like the plugin
        plugin_args['simulation'] = self               # allows access of plugin to globals
        super(Plugin, self).__init__(**kwargs)
        self.plugins[self.plugin_name] = self.plugin_class(**plugin_args)  # add the worker

