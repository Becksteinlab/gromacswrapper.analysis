# $Id$
# Copyright (c) 2009 Oliver Beckstein <orbeckst@gmail.com>
# Released under the GNU Public License 3 (or higher, your choice)
# See the file COPYING for details.

"""
:mod:`analysis.core` -- Core classes for analysis of Gromacs trajectories
=========================================================================

This documentation is mostly of interest to programmers who want to write
analysis plugins.


Programming API for plugins
---------------------------

Additional analysis capabilities are added to a
:class:`gromacs.analysis.Simulation` class with *plugin* classes.

Example usage
.............

Derive class for the simulation of interest along the lines of ::

     from gromacs.analysis import Simulation
     from gromacs.analysis.plugins import CysAccessibility, Distances

     class MyProtein(Simulation):
       def __init__(self,**kwargs):
           kwargs['CysAccessibility'] = {'cysteines': [96, 243, 372]}  # default for CysAccessibility
           super(MyProtein,self).__init__(**kwargs)

     S = MyProtein(tpr=..., xtc=..., analysisdir=..., plugins=[CysAccessibility, Distances])
     S.set_plugin('CysAccessibility')          # do CysAccessibility for now
     S.run()                                   # generate data from trajectories
     S.analyze()                               # analyze data
     S.plot(figure=True)                       # plot and save figures


API description
...............

Analysis capabilities can be added with plugins to the simulation base
class. Each plugin registers itself and provides at a minimum
:meth:`run()`, :meth:`analyze()`, and :meth:`plot()` methods.

The plugin class is derived from :class:`Plugin` and bears the name that is used to
access it. When its :meth:`__init__` method executes it adds the actual worker class
(typically named with the underscore-prepended name) to the :attr:`Simulation.plugins`
dictionary.

Variables for initializing a plugin are given to the class constructor as a
keyword argument that is named like the plugin and contains a dictionary that
is used as the keyword parameters for the plugin's init.

A plugin **must** obtain a pointer to the :class:`Simulation` class as the keyword
argument ``simulation`` in order to be able to access simulation-global
parameters such as top directories or input files.

See :class:`analysis.plugins.CysAccessibility` and
:class:`analysis.plugins._CysAccessibility` in
``analysis/plugins/CysAccessibility.py`` as examples.


API requirements
................

* Each plugin is contained in a separate module in the
  :mod:`gromacs.analysis.plugins` package. The name of the module *must* be the
  name of the plugin class in all lower case.

* The plugin name is registered in
  :const:`gromacs.analysis.plugins.__plugins__`. (Together with the file naming
  convention this allows for automatic and consistent loading.)

* The plugin itself is derived from :class:`Plugin`; the only changes are the
  doc strings and setting the :attr:`Plugin.plugin_name` class attribute.

* The corresponding worker class is derived from :class:`Worker` and must implement 
  
  - :meth:`Worker.__init__` which can only use keyword arguments to initialize
    the plugin. It must ensure that init methods of super classes are also
    called. See the existing plugins for details.

  - :meth:`Worker.run` which typically generates the data by analyzing a
    trajectory, possibly multiple times. It should store results in files.

  - :meth:`Worker.analyze` analyzes the data generated by :meth:`Worker.run`.

  - :meth:`Worker.plot` plots the analyzed data.

* The worker class can access parameters of the simulation via the
  :attr:`Worker.simulation` attribute that is automatically set when the plugin
  registers itself with :class:`Simulations`. However, the plugin should *not*
  rely on :attr:`~Worker.simulation` being present during initialization
  (__init__) because registration of the plugin might occur *after* init.

  This also means that one cannot use the directory methods such as
  :meth:`Worker.plugindir` because they depend on :meth:`Simulation.topdir` and
  :meth:`Simulation.plugindir`. 

  Any initialization that requires access to the :class:`Simulation` instance
  should be moved into the :meth:`Worker._register_hook` method. It is called
  when the plugin is actually being registered. Note that the hook should also
  call the hook of the super class before setting any values. The hook should
  pop any arguments that it requires and ignore everything else.

* Parameters of the plugin are stored in :attr:`Worker.parameters` (either as
  attributes or as key/value pairs, see the container class
  :class:`gromacs.utilities.AttributeDict`).

* Results are stored in :attr:`Worker.results` (also a :class:`gromacs.utilities.AttributeDict`).


Classes
-------

.. autoclass:: Simulation
   :members: __init__, add_plugin, set_default_plugin, run, analyze, plot, 
            topdir, plugindir, check_file, has_plugin, check_plugin_name, select_plugin

.. autoclass:: Plugin
   :members: __init__, plugin_name, worker_class

.. autoclass:: Worker   
   :members: __init__, topdir, plugindir, savefig
   :show-inheritance:

"""
__docformat__ = "restructuredtext en"

import sys
import os
import errno
import subprocess
import warnings

from gromacs.utilities import FileUtils, AttributeDict


class Simulation(object):
    """Class that represents one simulation.

    Analysis capabilities are added via plugins. 

    1. Set the *active plugin* with the :meth:`set_default_plugin` method. 
    2. Analyze the trajectory with the active plugin by calling the 
       :meth:`run` method.
    3. Analyze the output from :meth:`run` with :meth:`analyze`; results are stored 
       in :attr:`results`. 
    4. Plot results with :meth:`plot`.

    Detailed listing of methods:

    """
    def __init__(self, **kwargs):
        """Set up a Simulation object; analysis is performed via methods.

        :Keywords:
           tpr
             Gromacs tpr file (**required**)
           xtc
             Gromacs trajectory (**required**)
           ndx
             Gromacs index file
           analysisdir
             directory under which derived data are stored;
             defaults to the directory containing the tpr [None]
           plugins : list
             plugin classes (not instances!) or names (strings) to be used; more 
             can be added later with :meth:`Simulation.add_plugin`.
        """
        super(Simulation, self).__init__(**kwargs)

        # required files
        self.tpr = kwargs.pop('tpr',None)
        self.xtc = kwargs.pop('xtc',None)
        for v in ('tpr', 'xtc'):            
            self.check_file(v, self.__getattribute__(v))

        self.ndx = kwargs.pop('ndx',None)
        self.analysis_dir = kwargs.pop('analysisdir', os.path.dirname(self.tpr))

        # registry for plugins: This dict is central.
        self.plugins = AttributeDict()   # nicer for interactive use than dict
        self.default_plugin_name = None

        plugin_classes = kwargs.pop('plugins', [])
        for P in plugin_classes:
            self._add_plugin(P, **kwargs)

        # convenience: if only a single plugin was registered we default to that one
        if len(self.plugins) == 1:
            self.set_default_plugin(self.plugins.keys()[0])

    def _add_plugin(self, plugin_class, **kwargs):
        """Create a plugin instance from plugin_class and add it to the registry.

        This is the 'real' add_plugin method. Notably, it requires plugin
        arguments to apckaged in a dict that is named like the pligin. A user
        should simply use the :meth:`add_plugin` method with its more intuitive
        calling convention.

        :Arguments:
            plugin_class : class or string
               If the parameter is a class then it should have been derived
               from :class:`Plugin`. If it is a string then it is taken as a
               plugin name in :mod:`gromacs.analysis.plugins` and the
               corresponding class is added.
            kwargs
               Keyword arguments are all passed to the plugin constructor,
               which ignores everything except an argument that has the name of
               the plugin itself. This must be a dict with all the parameters
               that are needed to initialize the plugin (or rather its worker
               class). For example, the
               :class:`~gromacs.analysis.plugins.CysAccessibility` plugin would
               only use a keyword argument such as
               ``CysAccessibility={'cysteines': [23, 123, 456]}`` and ignore
               everythin else. The contents of the dict are specific for the
               plugin and should be described in its documentation.

        The convoluted way to pass arguments is necessary so that the
        :class:`Simulation` class constructor can initialize all plugins
        immediately without worrying about clashes of keyword argument names in
        the individual plugins.
        """
        # 1. self must be provided so that plugin knows who owns it
        # 2. plugin_class.__init__ will take a dict of name plugin_class.plugin_name
        #    to initialize the Worker (... yes, it's convoluted...)
        # 3. plugin_class registers itself in self.plugins
        if type(plugin_class) is str:
            import plugins            # XXX: hope we can import this safely now...
            plugin_class = plugins.__plugin_classes__[plugin_class]
        plugin_class(simulation=self, **kwargs)  # simulation=self is REQUIRED!

    def add_plugin(self, plugin_class, **kwargs):
        """Create a plugin instance from plugin_class and add it to the registry.

        :Arguments:
            plugin_class : class or string
               If the parameter is a class then it should have been derived
               from :class:`Plugin`. If it is a string then it is taken as a
               plugin name in :mod:`gromacs.analysis.plugins` and the
               corresponding class is added.
            kwargs
               Keyword arguments are all passed to the plugin constructor,
        """
        try:
            plugin_name = plugin_class.plugin_name
        except AttributeError:
            plugin_name = plugin_class
        plugin_args = {plugin_name: kwargs}    # wrap all arguments in dict to be passed to Plugin init
        self._add_plugin(plugin_class, **plugin_args)
        

    def topdir(self,*args):
        """Returns path under self.analysis_dir. Parent dirs are created if necessary."""
        p = os.path.join(self.analysis_dir, *args)
        parent = os.path.dirname(p)
        try:
            os.makedirs(parent)
        except OSError,err:
            if err.errno != errno.EEXIST:
                raise
        return p

    def plugindir(self, plugin_name, *args):
        return self.select_plugin(plugin_name).plugindir(*args)

    def check_file(self,filetype,path):
        """Raise :exc:`ValueError` if path does not exist. Uses *filetype* in message."""
        if path is None or not os.path.isfile(path):
            raise ValueError("Missing required file %(filetype)r, got %(path)r." % vars())
        return True

    def check_plugin_name(self,plugin_name):
        """Raises a exc:`ValueError` if *plugin_name* is not registered."""
        if not (plugin_name is None or self.has_plugin(plugin_name)):
            raise ValueError('plugin_name must be None or one of\n%r\n' % self.plugins.keys())

    def has_plugin(self,plugin_name):
        """Returns True if *plugin_name* is registered."""
        return plugin_name in self.plugins

    def set_plugin(self,plugin_name):
        """Set the plugin that should be used by default.

        If no *plugin_name* is supplied to :meth:`run`, :meth:`analyze` etc. then
        this will be used.
        """
        if plugin_name == None:
            self.default_plugin_name = None
        else:
            self.check_plugin_name(plugin_name)
            self.default_plugin_name = plugin_name
        return self.default_plugin_name

    set_default_plugin = set_plugin  # deprecated

    def get_plugin(self,plugin_name=None):
        """Return valid plugin or the default for *plugin_name*=``None``."""
        self.check_plugin_name(plugin_name)
        if plugin_name is None:
            if self.default_plugin_name is None:
                raise ValueError('No default plugin was set.')
            plugin_name = self.default_plugin_name
        return self.plugins[plugin_name]

    @property
    def current_plugin(self):
        """The currently active plugin (set with :meth:`Simulation.set_plugin`)."""
        return self.get_plugin()

    select_plugin = get_plugin     # deprecated

    def run(self,plugin_name=None,**kwargs):
        """Generate data files as prerequisite to analysis."""
        return self.select_plugin(plugin_name).run(**kwargs)

    def analyze(self,plugin_name=None,**kwargs):
        """Run analysis for the plugin."""
        return self.select_plugin(plugin_name).analyze(**kwargs)    

    def plot(self,plugin_name=None,figure=False,**kwargs):
        """Plot all data for the selected plugin::

          plot(plugin_name, **kwargs)

        :Arguments:
           plugin_name   
              name of the plugin to plot data from
           figure
              - True: plot to file with default name.
              - string: use this filename (+extension for format)
              - False: only display
           kwargs
              arguments for plugin plot function and possibly :func:`pylab.plot`
        """
        kwargs['figure'] = figure
        return self.select_plugin(plugin_name).plot(**kwargs)    

    def __str__(self):
        return 'Simulation(tpr=%(tpr)r,xtc=%(xtc)r,analysisdir=%(analysis_dir)r)' % vars(self)
    def __repr__(self):
        return str(self)



# Plugin infrastructure
# ---------------------

# worker classes (used by the plugins)

class Worker(FileUtils):
    """Base class for a plugin worker."""

    #: name of the plugin that this Worker belongs to; set when deriving the 
    #: plugin's worker class
    plugin_name = None

    def __init__(self,**kwargs):
        """Set up Worker class.
        
        :Keywords:
          simulation
             A ``Simulation`` object; this is filled in by the ``Plugin`` class when the plugin 
             is registered (**required**).
          kwargs
             All other keyword arguments are passed to the super class.
        """
        assert self.plugin_name != None                  # derive from Worker
        self.simulation = kwargs.pop('simulation',None)  # eventually needed but can come after init
        self.location = None          # directory name under analysisdir (set in derived class)
        self.results = AttributeDict()
        self.parameters = AttributeDict()
        super(Worker,self).__init__(**kwargs)

        # note: We are NOT calling self._register_hook() here; subclasses do this
        #       themselves and it cascades via super(cls, self)._register_hook().

    def _register_hook(self, **kwargs):
        """Things to initialize once the :class:`Simulation` instance is known.

        The hook is called from :meth:`Plugin.register`.

        .. Note:: Subclasses should do all their :class:`Simulation` -
                  dependent initialization in their own :meth:`_register_hook` which
                  **must** call the super class hook via the :class:`super`
                  mechanism.
        """

        simulation = kwargs.pop('simulation', self.simulation)
        # XXX: should we 
        # XXX: 'try: super(Worker, self)._register_hook(**kwargs) except AttributeError: pass' 
        # XXX: just in case?
        if not simulation is None:
            self.simulation = simulation

    def topdir(self, *args):
        """Returns a directory located under the simulation top directory."""
        return self.simulation.topdir(*args)
    
    def plugindir(self, *args):
        """Returns a directory located under the plugin top directory."""
        return self.topdir(self.location, *args)

    def run(self,**kwargs):
        raise NotImplementedError

    def analyze(self,**kwargs):
        raise NotImplementedError

    def plot(self,**kwargs):
        raise NotImplementedError

    def savefig(self, filename=None, ext='png'):
        """Save the current figure under the default name, using the supplied format and extension."""
        import pylab
        if filename is None:
            filename = self.parameters.figname
        _filename = self.filename(filename, ext=ext, use_my_ext=True)
        pylab.savefig(_filename)
        print "Saved figure as %(_filename)r." % vars()
            

# plugins:
# registers a worker class in Simulation.plugins and adds a pointer to Simulation to worker

class Plugin(object):
    """Plugin class that can be added to a :class:`Simulation` instance.

    All analysis plugins must be derived from this base class.

    If a :class:`Simulation` instance is provided to the constructore in the
    *simulation* keyword argument then the plugin instantiates and registers a
    worker class in :attr:`Simulation.plugins` and adds the :class:`Simulation`
    instance to the worker.

    Otherwise the :meth:`Plugin.register` method must be called explicitly with
    a :class:`Simulation` instance.
    """    
    #: name of the plugin
    plugin_name = None
    #: actual plugin :class:`Worker` class (name with leading underscore)
    worker_class = None

    def __init__(self,simulation=None,**kwargs):
        """Registers the plugin with the simulation class.

        Specific keyword arguments are listed below, all other kwargs
        are passed through.

        :Arguments:
           simulation : Simulation instance
                The :class:`Simulation` instance that owns this plugin instance. Can be
                ``None`` but then the :meth:`register` method has to be called manually
                with a simulation instance later.
           *plugin_name* : dict     
                A dictionary named like the plugin is taken to include
                keyword arguments that are passed to the __init__ of the plugin.
        """
        print "DEBUG: plugin() registering %r" % self.plugin_name

        assert self.plugin_name != None                # must derive from Plugin
        assert issubclass(self.worker_class, Worker)   # must be a Worker

        self.__is_registered = False

        plugin_args = kwargs.pop(self.plugin_name,{})  # must be a dict named like the plugin
        plugin_args['simulation'] = simulation         # allows access of plugin to globals
        #: The :class:`Worker` instance of the plugin.
        self.worker = self.worker_class(**plugin_args) # create Worker instance

        if not simulation is None:                     # can delay registration
            self.register(simulation)
        #: The :class:`Simulation` instance who owns the plugin. Can be ``None`` 
        #: until a successful call to :meth:`~Plugin.register`.
        self.simulation = simulation

        super(Plugin, self).__init__(**kwargs)

    def register(self, simulation):
        """Register the plugin with the :class:`Simulation` instance.

        This method also ensures that the worker class knows the simulation
        instance. This is typically required for its :meth:`~Worker.run`,
        :meth:`~Worker.analyze`, and :meth:`~Worker.plot` methods.
        """

        assert simulation != None                      # must know who we belong to
        assert self.__is_registered == False           # only register once (necessary?)

        self.simulation = simulation                   # update our own
        self.worker._register_hook(simulation=simulation)    # HACK!!! patch simulation into worker & do more
        simulation.plugins[self.plugin_name] = self.worker  # add the worker to simulation

        self.__is_registered = True
        
